// Generated by Haxe 4.3.1
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_WorldMap
#include <WorldMap.h>
#endif
#ifndef INCLUDED_algorithm_AI
#include <algorithm/AI.h>
#endif
#ifndef INCLUDED_algorithm_Node
#include <algorithm/Node.h>
#endif
#ifndef INCLUDED_algorithm_PriorityQueue
#include <algorithm/PriorityQueue.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_algorithm_Node
#include <haxe/ds/GenericCell_algorithm_Node.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_algorithm_Node
#include <haxe/ds/GenericStack_algorithm_Node.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_587c33a1a9b89450_9_findPath,"algorithm.AI","findPath",0x37190445,"algorithm.AI.findPath","algorithm/AI.hx",9,0x573ba9f6)
HX_LOCAL_STACK_FRAME(_hx_pos_587c33a1a9b89450_29_retracePath,"algorithm.AI","retracePath",0x49b8d950,"algorithm.AI.retracePath","algorithm/AI.hx",29,0x573ba9f6)
HX_LOCAL_STACK_FRAME(_hx_pos_587c33a1a9b89450_57_neighbors,"algorithm.AI","neighbors",0xe6f65b9a,"algorithm.AI.neighbors","algorithm/AI.hx",57,0x573ba9f6)
HX_LOCAL_STACK_FRAME(_hx_pos_587c33a1a9b89450_87_heuristic,"algorithm.AI","heuristic",0xece36723,"algorithm.AI.heuristic","algorithm/AI.hx",87,0x573ba9f6)
HX_LOCAL_STACK_FRAME(_hx_pos_587c33a1a9b89450_90_sharePosList,"algorithm.AI","sharePosList",0x9e392e3a,"algorithm.AI.sharePosList","algorithm/AI.hx",90,0x573ba9f6)
namespace algorithm{

void AI_obj::__construct() { }

Dynamic AI_obj::__CreateEmpty() { return new AI_obj; }

void *AI_obj::_hx_vtable = 0;

Dynamic AI_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< AI_obj > _hx_result = new AI_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool AI_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x6868f12b;
}

::Array< ::Dynamic> AI_obj::visitedNodes;

 ::algorithm::Node AI_obj::findPath(int cost, ::algorithm::Node start, ::algorithm::Node end, ::WorldMap world){
            	HX_GC_STACKFRAME(&_hx_pos_587c33a1a9b89450_9_findPath)
HXLINE(  10)		 ::algorithm::PriorityQueue openList =  ::algorithm::PriorityQueue_obj::__alloc( HX_CTX );
HXLINE(  11)		 ::algorithm::Node current = null();
HXLINE(  12)		::algorithm::AI_obj::visitedNodes = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  14)		{
HXLINE(  14)			int _g = 0;
HXDLIN(  14)			::Array< ::Dynamic> _g1 = ::algorithm::AI_obj::neighbors(start,cost,world);
HXDLIN(  14)			while((_g < _g1->length)){
HXLINE(  14)				 ::algorithm::Node n = _g1->__get(_g).StaticCast<  ::algorithm::Node >();
HXDLIN(  14)				_g = (_g + 1);
HXLINE(  15)				bool _hx_tmp;
HXDLIN(  15)				if (!(::algorithm::AI_obj::sharePosList(n,::algorithm::AI_obj::visitedNodes))) {
HXLINE(  15)					_hx_tmp = (n->_hx_char != HX_(".",2e,00,00,00));
            				}
            				else {
HXLINE(  15)					_hx_tmp = true;
            				}
HXDLIN(  15)				if (_hx_tmp) {
HXLINE(  16)					continue;
            				}
HXLINE(  19)				n->h = ::algorithm::AI_obj::heuristic(n,end);
HXLINE(  20)				n->g = (start->g + cost);
HXLINE(  21)				openList->addByF(n);
            			}
            		}
HXLINE(  24)		 ::haxe::ds::GenericCell_algorithm_Node k = openList->head;
HXDLIN(  24)		if (::hx::IsNull( k )) {
HXLINE(  24)			current = null();
            		}
            		else {
HXLINE(  24)			openList->head = k->next;
HXDLIN(  24)			current = k->elt;
            		}
HXLINE(  25)		::algorithm::AI_obj::visitedNodes->push(current);
HXLINE(  26)		return current;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(AI_obj,findPath,return )

::Array< ::Dynamic> AI_obj::retracePath( ::algorithm::Node node){
            	HX_STACKFRAME(&_hx_pos_587c33a1a9b89450_29_retracePath)
HXLINE(  30)		::Array< ::Dynamic> path = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  32)		while(::hx::IsNotNull( node->parent )){
HXLINE(  33)			::String direction = HX_("",00,00,00,00);
HXLINE(  35)			{
HXLINE(  35)				Float value = ( (Float)((node->y - node->parent->y)) );
HXDLIN(  35)				Float _g;
HXDLIN(  35)				if ((value < -1)) {
HXLINE(  35)					_g = ( (Float)(-1) );
            				}
            				else {
HXLINE(  35)					if ((value > 1)) {
HXLINE(  35)						_g = ( (Float)(1) );
            					}
            					else {
HXLINE(  35)						_g = value;
            					}
            				}
HXDLIN(  35)				Float _hx_switch_0 = _g;
            				if (  (_hx_switch_0==( (Float)(-1) )) ){
HXLINE(  39)					direction = HX_("u",75,00,00,00);
HXDLIN(  39)					goto _hx_goto_3;
            				}
            				if (  (_hx_switch_0==( (Float)(1) )) ){
HXLINE(  37)					direction = HX_("d",64,00,00,00);
HXDLIN(  37)					goto _hx_goto_3;
            				}
            				_hx_goto_3:;
            			}
HXLINE(  42)			{
HXLINE(  42)				Float value1 = ( (Float)((node->x - node->parent->x)) );
HXDLIN(  42)				Float _g1;
HXDLIN(  42)				if ((value1 < -1)) {
HXLINE(  42)					_g1 = ( (Float)(-1) );
            				}
            				else {
HXLINE(  42)					if ((value1 > 1)) {
HXLINE(  42)						_g1 = ( (Float)(1) );
            					}
            					else {
HXLINE(  42)						_g1 = value1;
            					}
            				}
HXDLIN(  42)				Float _hx_switch_1 = _g1;
            				if (  (_hx_switch_1==( (Float)(-1) )) ){
HXLINE(  46)					direction = HX_("l",6c,00,00,00);
HXDLIN(  46)					goto _hx_goto_4;
            				}
            				if (  (_hx_switch_1==( (Float)(1) )) ){
HXLINE(  44)					direction = HX_("r",72,00,00,00);
HXDLIN(  44)					goto _hx_goto_4;
            				}
            				_hx_goto_4:;
            			}
HXLINE(  49)			node->parent->direction = direction;
HXLINE(  50)			path->insert(0,node);
HXLINE(  51)			node = node->parent;
            		}
HXLINE(  54)		return path;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(AI_obj,retracePath,return )

::Array< ::Dynamic> AI_obj::neighbors( ::algorithm::Node current,int cost, ::WorldMap world){
            	HX_GC_STACKFRAME(&_hx_pos_587c33a1a9b89450_57_neighbors)
HXLINE(  58)		Float value = ( (Float)((current->y - cost)) );
HXDLIN(  58)		Float max = ( (Float)(world->height) );
HXDLIN(  58)		Float j;
HXDLIN(  58)		if ((value < 1)) {
HXLINE(  58)			j = ( (Float)(1) );
            		}
            		else {
HXLINE(  58)			if ((value > max)) {
HXLINE(  58)				j = max;
            			}
            			else {
HXLINE(  58)				j = value;
            			}
            		}
HXDLIN(  58)		int j1 = ::Std_obj::_hx_int(j);
HXLINE(  59)		Float value1 = ( (Float)((current->y + cost)) );
HXDLIN(  59)		Float max1 = ( (Float)(world->height) );
HXDLIN(  59)		Float jl;
HXDLIN(  59)		if ((value1 < 1)) {
HXLINE(  59)			jl = ( (Float)(1) );
            		}
            		else {
HXLINE(  59)			if ((value1 > max1)) {
HXLINE(  59)				jl = max1;
            			}
            			else {
HXLINE(  59)				jl = value1;
            			}
            		}
HXDLIN(  59)		int jl1 = ::Std_obj::_hx_int(jl);
HXLINE(  61)		::Array< ::Dynamic> n = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  63)		while((j1 <= jl1)){
HXLINE(  64)			Float value2 = ( (Float)((current->x - cost)) );
HXDLIN(  64)			Float max2 = ( (Float)(world->width) );
HXDLIN(  64)			Float i;
HXDLIN(  64)			if ((value2 < 0)) {
HXLINE(  64)				i = ( (Float)(0) );
            			}
            			else {
HXLINE(  64)				if ((value2 > max2)) {
HXLINE(  64)					i = max2;
            				}
            				else {
HXLINE(  64)					i = value2;
            				}
            			}
HXDLIN(  64)			int i1 = ::Std_obj::_hx_int(i);
HXLINE(  65)			Float value3 = ( (Float)((current->x + cost)) );
HXDLIN(  65)			Float max3 = ( (Float)(world->width) );
HXDLIN(  65)			Float il;
HXDLIN(  65)			if ((value3 < 0)) {
HXLINE(  65)				il = ( (Float)(0) );
            			}
            			else {
HXLINE(  65)				if ((value3 > max3)) {
HXLINE(  65)					il = max3;
            				}
            				else {
HXLINE(  65)					il = value3;
            				}
            			}
HXDLIN(  65)			int il1 = ::Std_obj::_hx_int(il);
HXLINE(  67)			while((i1 <= il1)){
HXLINE(  68)				bool _hx_tmp;
HXDLIN(  68)				bool _hx_tmp1;
HXDLIN(  68)				if ((i1 != current->x)) {
HXLINE(  68)					_hx_tmp1 = (j1 != current->y);
            				}
            				else {
HXLINE(  68)					_hx_tmp1 = false;
            				}
HXDLIN(  68)				if (!(_hx_tmp1)) {
HXLINE(  68)					if ((i1 == current->x)) {
HXLINE(  68)						_hx_tmp = (j1 == current->y);
            					}
            					else {
HXLINE(  68)						_hx_tmp = false;
            					}
            				}
            				else {
HXLINE(  68)					_hx_tmp = true;
            				}
HXDLIN(  68)				if (_hx_tmp) {
HXLINE(  69)					i1 = (i1 + 1);
HXLINE(  70)					continue;
            				}
HXLINE(  73)				 ::algorithm::Node node =  ::algorithm::Node_obj::__alloc( HX_CTX ,i1,j1);
HXLINE(  74)				node->_hx_char = world->matrix->__get(i1).StaticCast< ::Array< ::String > >()->__get(j1);
HXLINE(  75)				n->push(node);
HXLINE(  77)				i1 = (i1 + 1);
            			}
HXLINE(  80)			j1 = (j1 + 1);
            		}
HXLINE(  83)		return n;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(AI_obj,neighbors,return )

int AI_obj::heuristic( ::algorithm::Node start, ::algorithm::Node end){
            	HX_STACKFRAME(&_hx_pos_587c33a1a9b89450_87_heuristic)
HXDLIN(  87)		return ::Std_obj::_hx_int((::Math_obj::abs(( (Float)((start->x - end->x)) )) + ::Math_obj::abs(( (Float)((start->y - end->y)) ))));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(AI_obj,heuristic,return )

bool AI_obj::sharePosList( ::algorithm::Node target,::Array< ::Dynamic> list){
            	HX_STACKFRAME(&_hx_pos_587c33a1a9b89450_90_sharePosList)
HXLINE(  91)		{
HXLINE(  91)			int _g = 0;
HXDLIN(  91)			while((_g < list->length)){
HXLINE(  91)				 ::algorithm::Node node = list->__get(_g).StaticCast<  ::algorithm::Node >();
HXDLIN(  91)				_g = (_g + 1);
HXLINE(  92)				bool _hx_tmp;
HXDLIN(  92)				if ((node->x == target->x)) {
HXLINE(  92)					_hx_tmp = (node->y == target->y);
            				}
            				else {
HXLINE(  92)					_hx_tmp = false;
            				}
HXDLIN(  92)				if (_hx_tmp) {
HXLINE(  93)					return true;
            				}
            			}
            		}
HXLINE(  97)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(AI_obj,sharePosList,return )


AI_obj::AI_obj()
{
}

bool AI_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"findPath") ) { outValue = findPath_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"neighbors") ) { outValue = neighbors_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"heuristic") ) { outValue = heuristic_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"retracePath") ) { outValue = retracePath_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"visitedNodes") ) { outValue = ( visitedNodes ); return true; }
		if (HX_FIELD_EQ(inName,"sharePosList") ) { outValue = sharePosList_dyn(); return true; }
	}
	return false;
}

bool AI_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"visitedNodes") ) { visitedNodes=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *AI_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo AI_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(void *) &AI_obj::visitedNodes,HX_("visitedNodes",e7,3c,5e,91)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void AI_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(AI_obj::visitedNodes,"visitedNodes");
};

#ifdef HXCPP_VISIT_ALLOCS
static void AI_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(AI_obj::visitedNodes,"visitedNodes");
};

#endif

::hx::Class AI_obj::__mClass;

static ::String AI_obj_sStaticFields[] = {
	HX_("visitedNodes",e7,3c,5e,91),
	HX_("findPath",7e,f2,e5,9c),
	HX_("retracePath",b7,d4,e1,01),
	HX_("neighbors",41,df,79,94),
	HX_("heuristic",ca,ea,66,9a),
	HX_("sharePosList",f3,2c,ec,09),
	::String(null())
};

void AI_obj::__register()
{
	AI_obj _hx_dummy;
	AI_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("algorithm.AI",87,a3,06,2e);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &AI_obj::__GetStatic;
	__mClass->mSetStaticField = &AI_obj::__SetStatic;
	__mClass->mMarkFunc = AI_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(AI_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< AI_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = AI_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = AI_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = AI_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace algorithm
