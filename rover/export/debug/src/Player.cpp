// Generated by Haxe 4.3.1
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Main
#include <Main.h>
#endif
#ifndef INCLUDED_Player
#include <Player.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_WorldMap
#include <WorldMap.h>
#endif
#ifndef INCLUDED_algorithm_Node
#include <algorithm/Node.h>
#endif
#ifndef INCLUDED_algorithm_PriorityQueue
#include <algorithm/PriorityQueue.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_sys_io_File
#include <sys/io/File.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_9d6b32c958ffa4d3_38_new,"Player","new",0x8d5554f3,"Player.new","Player.hx",38,0xa27fc9dd)
HX_DEFINE_STACK_FRAME(_hx_pos_9d6b32c958ffa4d3_11_new,"Player","new",0x8d5554f3,"Player.new","Player.hx",11,0xa27fc9dd)
static const ::String _hx_array_data_6c4d5f81_2[] = {
	HX_("u",75,00,00,00),HX_("d",64,00,00,00),HX_("l",6c,00,00,00),HX_("r",72,00,00,00),
};
HX_LOCAL_STACK_FRAME(_hx_pos_9d6b32c958ffa4d3_42_pathMovement,"Player","pathMovement",0x6131a501,"Player.pathMovement","Player.hx",42,0xa27fc9dd)
HX_LOCAL_STACK_FRAME(_hx_pos_9d6b32c958ffa4d3_47_mapOut,"Player","mapOut",0x23fc309f,"Player.mapOut","Player.hx",47,0xa27fc9dd)
HX_LOCAL_STACK_FRAME(_hx_pos_9d6b32c958ffa4d3_99_scanArea,"Player","scanArea",0xa1ebbe37,"Player.scanArea","Player.hx",99,0xa27fc9dd)
HX_LOCAL_STACK_FRAME(_hx_pos_9d6b32c958ffa4d3_124_command,"Player","command",0xab683b5e,"Player.command","Player.hx",124,0xa27fc9dd)
HX_LOCAL_STACK_FRAME(_hx_pos_9d6b32c958ffa4d3_12_boot,"Player","boot",0x156e003f,"Player.boot","Player.hx",12,0xa27fc9dd)

void Player_obj::__construct( ::WorldMap world){
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(2)
            		int _hx_run( ::algorithm::Node a, ::algorithm::Node b){
            			HX_STACKFRAME(&_hx_pos_9d6b32c958ffa4d3_38_new)
HXLINE(  38)			return (b->priority - a->priority);
            		}
            		HX_END_LOCAL_FUNC2(return)

            	HX_GC_STACKFRAME(&_hx_pos_9d6b32c958ffa4d3_11_new)
HXLINE(  26)		this->_hx___directions = ::Array_obj< ::String >::fromData( _hx_array_data_6c4d5f81_2,4);
HXLINE(  25)		this->_hx___directory = HX_("../../../",8f,8c,ef,d0);
HXLINE(  30)		this->x = 0;
HXLINE(  31)		this->y = 0;
HXLINE(  32)		this->level = 1;
HXLINE(  33)		this->sight = 2;
HXLINE(  35)		this->world = world;
HXLINE(  37)		this->_hx___rockQueue =  ::algorithm::PriorityQueue_obj::__alloc( HX_CTX , ::Dynamic(new _hx_Closure_0()));
            	}

Dynamic Player_obj::__CreateEmpty() { return new Player_obj; }

void *Player_obj::_hx_vtable = 0;

Dynamic Player_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Player_obj > _hx_result = new Player_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool Player_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x33e526a5;
}

void Player_obj::pathMovement(){
            	HX_STACKFRAME(&_hx_pos_9d6b32c958ffa4d3_42_pathMovement)
HXLINE(  43)		this->scanArea();
HXLINE(  44)		this->mapOut();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Player_obj,pathMovement,(void))

void Player_obj::mapOut(){
            	HX_STACKFRAME(&_hx_pos_9d6b32c958ffa4d3_47_mapOut)
HXLINE(  48)		Float value = ( (Float)((this->y - this->level)) );
HXDLIN(  48)		Float max = ( (Float)(this->world->height) );
HXDLIN(  48)		Float j;
HXDLIN(  48)		if ((value < 1)) {
HXLINE(  48)			j = ( (Float)(1) );
            		}
            		else {
HXLINE(  48)			if ((value > max)) {
HXLINE(  48)				j = max;
            			}
            			else {
HXLINE(  48)				j = value;
            			}
            		}
HXDLIN(  48)		int j1 = ::Std_obj::_hx_int(j);
HXLINE(  49)		Float value1 = ( (Float)((this->y + this->level)) );
HXDLIN(  49)		Float max1 = ( (Float)(this->world->height) );
HXDLIN(  49)		Float jl;
HXDLIN(  49)		if ((value1 < 1)) {
HXLINE(  49)			jl = ( (Float)(1) );
            		}
            		else {
HXLINE(  49)			if ((value1 > max1)) {
HXLINE(  49)				jl = max1;
            			}
            			else {
HXLINE(  49)				jl = value1;
            			}
            		}
HXDLIN(  49)		int jl1 = ::Std_obj::_hx_int(jl);
HXLINE(  51)		::String direction = HX_("",00,00,00,00);
HXLINE(  52)		::String mine = HX_("",00,00,00,00);
HXLINE(  54)		while((j1 <= jl1)){
HXLINE(  55)			Float value2 = ( (Float)((this->x - this->level)) );
HXDLIN(  55)			Float max2 = ( (Float)(this->world->width) );
HXDLIN(  55)			Float i;
HXDLIN(  55)			if ((value2 < 0)) {
HXLINE(  55)				i = ( (Float)(0) );
            			}
            			else {
HXLINE(  55)				if ((value2 > max2)) {
HXLINE(  55)					i = max2;
            				}
            				else {
HXLINE(  55)					i = value2;
            				}
            			}
HXDLIN(  55)			int i1 = ::Std_obj::_hx_int(i);
HXLINE(  56)			Float value3 = ( (Float)((this->x + this->level)) );
HXDLIN(  56)			Float max3 = ( (Float)(this->world->width) );
HXDLIN(  56)			Float il;
HXDLIN(  56)			if ((value3 < 0)) {
HXLINE(  56)				il = ( (Float)(0) );
            			}
            			else {
HXLINE(  56)				if ((value3 > max3)) {
HXLINE(  56)					il = max3;
            				}
            				else {
HXLINE(  56)					il = value3;
            				}
            			}
HXDLIN(  56)			int il1 = ::Std_obj::_hx_int(il);
HXLINE(  58)			while((i1 <= il1)){
HXLINE(  59)				bool _hx_tmp;
HXDLIN(  59)				bool _hx_tmp1;
HXDLIN(  59)				bool _hx_tmp2;
HXDLIN(  59)				if ((i1 != this->x)) {
HXLINE(  59)					_hx_tmp2 = (j1 != this->y);
            				}
            				else {
HXLINE(  59)					_hx_tmp2 = false;
            				}
HXDLIN(  59)				if (!(_hx_tmp2)) {
HXLINE(  59)					if ((i1 == this->x)) {
HXLINE(  59)						_hx_tmp1 = (j1 == this->y);
            					}
            					else {
HXLINE(  59)						_hx_tmp1 = false;
            					}
            				}
            				else {
HXLINE(  59)					_hx_tmp1 = true;
            				}
HXDLIN(  59)				if (!(_hx_tmp1)) {
HXLINE(  59)					_hx_tmp = (this->world->matrix->__get(j1).StaticCast< ::Array< ::String > >()->__get(i1) == HX_("B",42,00,00,00));
            				}
            				else {
HXLINE(  59)					_hx_tmp = true;
            				}
HXDLIN(  59)				if (_hx_tmp) {
HXLINE(  60)					i1 = (i1 + 1);
HXLINE(  61)					continue;
            				}
HXLINE(  64)				if ((this->world->matrix->__get(j1).StaticCast< ::Array< ::String > >()->__get(i1) != HX_("F",46,00,00,00))) {
HXLINE(  65)					int randomDirection = ::Math_obj::floor((::Math_obj::random() * ( (Float)(4) )));
HXLINE(  66)					direction = this->_hx___directions->__get(randomDirection);
            				}
HXLINE(  69)				bool _hx_tmp3;
HXDLIN(  69)				if ((this->world->matrix->__get(j1).StaticCast< ::Array< ::String > >()->__get(i1) != HX_("C",43,00,00,00))) {
HXLINE(  69)					_hx_tmp3 = (this->world->matrix->__get(j1).StaticCast< ::Array< ::String > >()->__get(i1) == HX_("A",41,00,00,00));
            				}
            				else {
HXLINE(  69)					_hx_tmp3 = true;
            				}
HXDLIN(  69)				if (_hx_tmp3) {
HXLINE(  70)					{
HXLINE(  70)						Float value4 = ( (Float)((i1 - this->x)) );
HXDLIN(  70)						Float _g;
HXDLIN(  70)						if ((value4 < -1)) {
HXLINE(  70)							_g = ( (Float)(-1) );
            						}
            						else {
HXLINE(  70)							if ((value4 > 1)) {
HXLINE(  70)								_g = ( (Float)(1) );
            							}
            							else {
HXLINE(  70)								_g = value4;
            							}
            						}
HXDLIN(  70)						Float _hx_switch_0 = _g;
            						if (  (_hx_switch_0==( (Float)(-1) )) ){
HXLINE(  72)							mine = HX_("m l",f9,d1,52,00);
HXDLIN(  72)							goto _hx_goto_6;
            						}
            						if (  (_hx_switch_0==( (Float)(1) )) ){
HXLINE(  74)							mine = HX_("m r",ff,d1,52,00);
HXDLIN(  74)							goto _hx_goto_6;
            						}
            						_hx_goto_6:;
            					}
HXLINE(  77)					{
HXLINE(  77)						Float value5 = ( (Float)((j1 - this->y)) );
HXDLIN(  77)						Float _g1;
HXDLIN(  77)						if ((value5 < -1)) {
HXLINE(  77)							_g1 = ( (Float)(-1) );
            						}
            						else {
HXLINE(  77)							if ((value5 > 1)) {
HXLINE(  77)								_g1 = ( (Float)(1) );
            							}
            							else {
HXLINE(  77)								_g1 = value5;
            							}
            						}
HXDLIN(  77)						Float _hx_switch_1 = _g1;
            						if (  (_hx_switch_1==( (Float)(-1) )) ){
HXLINE(  79)							mine = HX_("m u",02,d2,52,00);
HXDLIN(  79)							goto _hx_goto_7;
            						}
            						if (  (_hx_switch_1==( (Float)(1) )) ){
HXLINE(  81)							mine = HX_("m d",f1,d1,52,00);
HXDLIN(  81)							goto _hx_goto_7;
            						}
            						_hx_goto_7:;
            					}
HXLINE(  84)					this->command(mine);
HXLINE(  85)					return;
            				}
HXLINE(  88)				i1 = (i1 + 1);
            			}
HXLINE(  91)			j1 = (j1 + 1);
            		}
HXLINE(  94)		if ((direction != HX_("",00,00,00,00))) {
HXLINE(  95)			this->command(direction);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Player_obj,mapOut,(void))

void Player_obj::scanArea(){
            	HX_GC_STACKFRAME(&_hx_pos_9d6b32c958ffa4d3_99_scanArea)
HXLINE( 100)		Float value = ( (Float)((this->y - this->sight)) );
HXDLIN( 100)		Float max = ( (Float)(this->world->height) );
HXDLIN( 100)		Float j;
HXDLIN( 100)		if ((value < 1)) {
HXLINE( 100)			j = ( (Float)(1) );
            		}
            		else {
HXLINE( 100)			if ((value > max)) {
HXLINE( 100)				j = max;
            			}
            			else {
HXLINE( 100)				j = value;
            			}
            		}
HXDLIN( 100)		int j1 = ::Std_obj::_hx_int(j);
HXLINE( 101)		Float value1 = ( (Float)((this->y + this->sight)) );
HXDLIN( 101)		Float max1 = ( (Float)(this->world->height) );
HXDLIN( 101)		Float jl;
HXDLIN( 101)		if ((value1 < 1)) {
HXLINE( 101)			jl = ( (Float)(1) );
            		}
            		else {
HXLINE( 101)			if ((value1 > max1)) {
HXLINE( 101)				jl = max1;
            			}
            			else {
HXLINE( 101)				jl = value1;
            			}
            		}
HXDLIN( 101)		int jl1 = ::Std_obj::_hx_int(jl);
HXLINE( 103)		while((j1 <= jl1)){
HXLINE( 104)			Float value2 = ( (Float)((this->x - this->sight)) );
HXDLIN( 104)			Float max2 = ( (Float)(this->world->width) );
HXDLIN( 104)			Float i;
HXDLIN( 104)			if ((value2 < 0)) {
HXLINE( 104)				i = ( (Float)(0) );
            			}
            			else {
HXLINE( 104)				if ((value2 > max2)) {
HXLINE( 104)					i = max2;
            				}
            				else {
HXLINE( 104)					i = value2;
            				}
            			}
HXDLIN( 104)			int i1 = ::Std_obj::_hx_int(i);
HXLINE( 105)			Float value3 = ( (Float)((this->x + this->sight)) );
HXDLIN( 105)			Float max3 = ( (Float)(this->world->width) );
HXDLIN( 105)			Float il;
HXDLIN( 105)			if ((value3 < 0)) {
HXLINE( 105)				il = ( (Float)(0) );
            			}
            			else {
HXLINE( 105)				if ((value3 > max3)) {
HXLINE( 105)					il = max3;
            				}
            				else {
HXLINE( 105)					il = value3;
            				}
            			}
HXDLIN( 105)			int il1 = ::Std_obj::_hx_int(il);
HXLINE( 107)			while((i1 <= il1)){
HXLINE( 108)				bool _hx_tmp;
HXDLIN( 108)				bool _hx_tmp1;
HXDLIN( 108)				if ((this->world->matrix->__get(j1).StaticCast< ::Array< ::String > >()->__get(i1) == HX_("C",43,00,00,00))) {
HXLINE( 108)					_hx_tmp1 = (this->world->matrix->__get(j1).StaticCast< ::Array< ::String > >()->__get(i1) != HX_("D",44,00,00,00));
            				}
            				else {
HXLINE( 108)					_hx_tmp1 = true;
            				}
HXDLIN( 108)				if (!(_hx_tmp1)) {
HXLINE( 108)					_hx_tmp = (this->world->matrix->__get(j1).StaticCast< ::Array< ::String > >()->__get(i1) != HX_("F",46,00,00,00));
            				}
            				else {
HXLINE( 108)					_hx_tmp = true;
            				}
HXDLIN( 108)				if (_hx_tmp) {
HXLINE( 111)					 ::algorithm::Node node =  ::algorithm::Node_obj::__alloc( HX_CTX ,i1,j1);
HXLINE( 112)					node->priority = ::Player_obj::priorities->get_int(this->world->matrix->__get(j1).StaticCast< ::Array< ::String > >()->__get(i1));
HXLINE( 113)					node->_hx_char = this->world->matrix->__get(j1).StaticCast< ::Array< ::String > >()->__get(i1);
HXLINE( 114)					this->_hx___rockQueue->add(node);
            				}
HXLINE( 117)				i1 = (i1 + 1);
            			}
HXLINE( 120)			j1 = (j1 + 1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Player_obj,scanArea,(void))

void Player_obj::command(::String cmd){
            	HX_STACKFRAME(&_hx_pos_9d6b32c958ffa4d3_124_command)
HXLINE( 125)		::haxe::Log_obj::trace(((this->x + HX_(" ",20,00,00,00)) + this->y),::hx::SourceInfo(HX_("source/Player.hx",69,3c,9f,51),125,HX_("Player",81,5f,4d,6c),HX_("command",4b,71,6d,81)));
HXLINE( 127)		::String client = (((((this->_hx___directory + HX_("game/c",c6,7d,f9,50)) + ::Main_obj::id) + HX_("_",5f,00,00,00)) + ::Main_obj::round) + HX_(".txt",02,3f,c0,1e));
HXLINE( 129)		::sys::io::File_obj::saveContent(client,(cmd + HX_("\n",0a,00,00,00)));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Player_obj,command,(void))

 ::haxe::ds::StringMap Player_obj::priorities;


::hx::ObjectPtr< Player_obj > Player_obj::__new( ::WorldMap world) {
	::hx::ObjectPtr< Player_obj > __this = new Player_obj();
	__this->__construct(world);
	return __this;
}

::hx::ObjectPtr< Player_obj > Player_obj::__alloc(::hx::Ctx *_hx_ctx, ::WorldMap world) {
	Player_obj *__this = (Player_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Player_obj), true, "Player"));
	*(void **)__this = Player_obj::_hx_vtable;
	__this->__construct(world);
	return __this;
}

Player_obj::Player_obj()
{
}

void Player_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Player);
	HX_MARK_MEMBER_NAME(x,"x");
	HX_MARK_MEMBER_NAME(y,"y");
	HX_MARK_MEMBER_NAME(sight,"sight");
	HX_MARK_MEMBER_NAME(level,"level");
	HX_MARK_MEMBER_NAME(world,"world");
	HX_MARK_MEMBER_NAME(facing,"facing");
	HX_MARK_MEMBER_NAME(_hx___directory,"__directory");
	HX_MARK_MEMBER_NAME(_hx___directions,"__directions");
	HX_MARK_MEMBER_NAME(_hx___rockQueue,"__rockQueue");
	HX_MARK_END_CLASS();
}

void Player_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(x,"x");
	HX_VISIT_MEMBER_NAME(y,"y");
	HX_VISIT_MEMBER_NAME(sight,"sight");
	HX_VISIT_MEMBER_NAME(level,"level");
	HX_VISIT_MEMBER_NAME(world,"world");
	HX_VISIT_MEMBER_NAME(facing,"facing");
	HX_VISIT_MEMBER_NAME(_hx___directory,"__directory");
	HX_VISIT_MEMBER_NAME(_hx___directions,"__directions");
	HX_VISIT_MEMBER_NAME(_hx___rockQueue,"__rockQueue");
}

::hx::Val Player_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { return ::hx::Val( x ); }
		if (HX_FIELD_EQ(inName,"y") ) { return ::hx::Val( y ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"sight") ) { return ::hx::Val( sight ); }
		if (HX_FIELD_EQ(inName,"level") ) { return ::hx::Val( level ); }
		if (HX_FIELD_EQ(inName,"world") ) { return ::hx::Val( world ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"facing") ) { return ::hx::Val( facing ); }
		if (HX_FIELD_EQ(inName,"mapOut") ) { return ::hx::Val( mapOut_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"command") ) { return ::hx::Val( command_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"scanArea") ) { return ::hx::Val( scanArea_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"__directory") ) { return ::hx::Val( _hx___directory ); }
		if (HX_FIELD_EQ(inName,"__rockQueue") ) { return ::hx::Val( _hx___rockQueue ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"__directions") ) { return ::hx::Val( _hx___directions ); }
		if (HX_FIELD_EQ(inName,"pathMovement") ) { return ::hx::Val( pathMovement_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Player_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"priorities") ) { outValue = ( priorities ); return true; }
	}
	return false;
}

::hx::Val Player_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { x=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y") ) { y=inValue.Cast< int >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"sight") ) { sight=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"level") ) { level=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"world") ) { world=inValue.Cast<  ::WorldMap >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"facing") ) { facing=inValue.Cast< ::String >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"__directory") ) { _hx___directory=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__rockQueue") ) { _hx___rockQueue=inValue.Cast<  ::algorithm::PriorityQueue >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"__directions") ) { _hx___directions=inValue.Cast< ::Array< ::String > >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool Player_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"priorities") ) { priorities=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
	}
	return false;
}

void Player_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("x",78,00,00,00));
	outFields->push(HX_("y",79,00,00,00));
	outFields->push(HX_("sight",5d,a0,ca,7c));
	outFields->push(HX_("level",84,15,63,72));
	outFields->push(HX_("world",52,96,64,ce));
	outFields->push(HX_("facing",1a,3f,05,e4));
	outFields->push(HX_("__directory",4d,3b,71,3e));
	outFields->push(HX_("__directions",74,10,a9,60));
	outFields->push(HX_("__rockQueue",8c,0c,a1,b8));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Player_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(Player_obj,x),HX_("x",78,00,00,00)},
	{::hx::fsInt,(int)offsetof(Player_obj,y),HX_("y",79,00,00,00)},
	{::hx::fsInt,(int)offsetof(Player_obj,sight),HX_("sight",5d,a0,ca,7c)},
	{::hx::fsInt,(int)offsetof(Player_obj,level),HX_("level",84,15,63,72)},
	{::hx::fsObject /*  ::WorldMap */ ,(int)offsetof(Player_obj,world),HX_("world",52,96,64,ce)},
	{::hx::fsString,(int)offsetof(Player_obj,facing),HX_("facing",1a,3f,05,e4)},
	{::hx::fsString,(int)offsetof(Player_obj,_hx___directory),HX_("__directory",4d,3b,71,3e)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(Player_obj,_hx___directions),HX_("__directions",74,10,a9,60)},
	{::hx::fsObject /*  ::algorithm::PriorityQueue */ ,(int)offsetof(Player_obj,_hx___rockQueue),HX_("__rockQueue",8c,0c,a1,b8)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo Player_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &Player_obj::priorities,HX_("priorities",c2,50,53,e4)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String Player_obj_sMemberFields[] = {
	HX_("x",78,00,00,00),
	HX_("y",79,00,00,00),
	HX_("sight",5d,a0,ca,7c),
	HX_("level",84,15,63,72),
	HX_("world",52,96,64,ce),
	HX_("facing",1a,3f,05,e4),
	HX_("__directory",4d,3b,71,3e),
	HX_("__directions",74,10,a9,60),
	HX_("__rockQueue",8c,0c,a1,b8),
	HX_("pathMovement",f4,d3,c0,45),
	HX_("mapOut",52,d7,08,b9),
	HX_("scanArea",aa,b7,75,10),
	HX_("command",4b,71,6d,81),
	::String(null()) };

static void Player_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Player_obj::priorities,"priorities");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Player_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Player_obj::priorities,"priorities");
};

#endif

::hx::Class Player_obj::__mClass;

static ::String Player_obj_sStaticFields[] = {
	HX_("priorities",c2,50,53,e4),
	::String(null())
};

void Player_obj::__register()
{
	Player_obj _hx_dummy;
	Player_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("Player",81,5f,4d,6c);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Player_obj::__GetStatic;
	__mClass->mSetStaticField = &Player_obj::__SetStatic;
	__mClass->mMarkFunc = Player_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Player_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Player_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Player_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Player_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Player_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Player_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Player_obj::__boot()
{
{
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            		 ::haxe::ds::StringMap _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_9d6b32c958ffa4d3_12_boot)
HXDLIN(  12)			 ::haxe::ds::StringMap _g =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXDLIN(  12)			_g->set(HX_("C",43,00,00,00),1);
HXDLIN(  12)			_g->set(HX_("D",44,00,00,00),2);
HXDLIN(  12)			return _g;
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_STACKFRAME(&_hx_pos_9d6b32c958ffa4d3_12_boot)
HXDLIN(  12)		priorities = ( ( ::haxe::ds::StringMap)( ::Dynamic(new _hx_Closure_0())()) );
            	}
}

