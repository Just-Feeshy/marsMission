// Generated by Haxe 4.3.1
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_spinehaxe_MathUtils
#include <spinehaxe/MathUtils.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_7db36b66451a9438_15_radToDeg,"spinehaxe.MathUtils","radToDeg",0xefda1220,"spinehaxe.MathUtils.radToDeg","spinehaxe/MathUtils.hx",15,0xb0800e3b)
HX_LOCAL_STACK_FRAME(_hx_pos_7db36b66451a9438_23_degToRad,"spinehaxe.MathUtils","degToRad",0xa88a609e,"spinehaxe.MathUtils.degToRad","spinehaxe/MathUtils.hx",23,0xb0800e3b)
HX_LOCAL_STACK_FRAME(_hx_pos_7db36b66451a9438_27_cosDeg,"spinehaxe.MathUtils","cosDeg",0x2022ea69,"spinehaxe.MathUtils.cosDeg","spinehaxe/MathUtils.hx",27,0xb0800e3b)
HX_LOCAL_STACK_FRAME(_hx_pos_7db36b66451a9438_31_sinDeg,"spinehaxe.MathUtils","sinDeg",0x0e232438,"spinehaxe.MathUtils.sinDeg","spinehaxe/MathUtils.hx",31,0xb0800e3b)
HX_LOCAL_STACK_FRAME(_hx_pos_7db36b66451a9438_42_clamp,"spinehaxe.MathUtils","clamp",0x57a6a391,"spinehaxe.MathUtils.clamp","spinehaxe/MathUtils.hx",42,0xb0800e3b)
HX_LOCAL_STACK_FRAME(_hx_pos_7db36b66451a9438_51_signum,"spinehaxe.MathUtils","signum",0x09a2927f,"spinehaxe.MathUtils.signum","spinehaxe/MathUtils.hx",51,0xb0800e3b)
HX_LOCAL_STACK_FRAME(_hx_pos_7db36b66451a9438_55_random,"spinehaxe.MathUtils","random",0x0cab74ad,"spinehaxe.MathUtils.random","spinehaxe/MathUtils.hx",55,0xb0800e3b)
HX_LOCAL_STACK_FRAME(_hx_pos_7db36b66451a9438_59_minInt,"spinehaxe.MathUtils","minInt",0xa802cd27,"spinehaxe.MathUtils.minInt","spinehaxe/MathUtils.hx",59,0xb0800e3b)
HX_LOCAL_STACK_FRAME(_hx_pos_7db36b66451a9438_63_maxInt,"spinehaxe.MathUtils","maxInt",0x136a4b55,"spinehaxe.MathUtils.maxInt","spinehaxe/MathUtils.hx",63,0xb0800e3b)
HX_LOCAL_STACK_FRAME(_hx_pos_7db36b66451a9438_4_boot,"spinehaxe.MathUtils","boot",0x4252f85c,"spinehaxe.MathUtils.boot","spinehaxe/MathUtils.hx",4,0xb0800e3b)
HX_LOCAL_STACK_FRAME(_hx_pos_7db36b66451a9438_5_boot,"spinehaxe.MathUtils","boot",0x4252f85c,"spinehaxe.MathUtils.boot","spinehaxe/MathUtils.hx",5,0xb0800e3b)
HX_LOCAL_STACK_FRAME(_hx_pos_7db36b66451a9438_7_boot,"spinehaxe.MathUtils","boot",0x4252f85c,"spinehaxe.MathUtils.boot","spinehaxe/MathUtils.hx",7,0xb0800e3b)
HX_LOCAL_STACK_FRAME(_hx_pos_7db36b66451a9438_8_boot,"spinehaxe.MathUtils","boot",0x4252f85c,"spinehaxe.MathUtils.boot","spinehaxe/MathUtils.hx",8,0xb0800e3b)
namespace spinehaxe{

void MathUtils_obj::__construct() { }

Dynamic MathUtils_obj::__CreateEmpty() { return new MathUtils_obj; }

void *MathUtils_obj::_hx_vtable = 0;

Dynamic MathUtils_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< MathUtils_obj > _hx_result = new MathUtils_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool MathUtils_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0a4cddec;
}

int MathUtils_obj::MAX_INT;

int MathUtils_obj::MIN_INT;

Float MathUtils_obj::radDeg;

Float MathUtils_obj::degRad;

Float MathUtils_obj::radToDeg(Float rad){
            	HX_STACKFRAME(&_hx_pos_7db36b66451a9438_15_radToDeg)
HXDLIN(  15)		return (::spinehaxe::MathUtils_obj::radDeg * rad);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(MathUtils_obj,radToDeg,return )

Float MathUtils_obj::degToRad(Float deg){
            	HX_STACKFRAME(&_hx_pos_7db36b66451a9438_23_degToRad)
HXDLIN(  23)		return (::spinehaxe::MathUtils_obj::degRad * deg);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(MathUtils_obj,degToRad,return )

Float MathUtils_obj::cosDeg(Float degrees){
            	HX_STACKFRAME(&_hx_pos_7db36b66451a9438_27_cosDeg)
HXDLIN(  27)		return ::Math_obj::cos((::spinehaxe::MathUtils_obj::degRad * degrees));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(MathUtils_obj,cosDeg,return )

Float MathUtils_obj::sinDeg(Float degrees){
            	HX_STACKFRAME(&_hx_pos_7db36b66451a9438_31_sinDeg)
HXDLIN(  31)		return ::Math_obj::sin((::spinehaxe::MathUtils_obj::degRad * degrees));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(MathUtils_obj,sinDeg,return )

Float MathUtils_obj::clamp(Float value,Float min,Float max){
            	HX_STACKFRAME(&_hx_pos_7db36b66451a9438_42_clamp)
HXDLIN(  42)		if ((value < min)) {
HXLINE(  43)			return min;
            		}
            		else {
HXLINE(  44)			if ((value > max)) {
HXLINE(  45)				return max;
            			}
            			else {
HXLINE(  47)				return value;
            			}
            		}
HXLINE(  42)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(MathUtils_obj,clamp,return )

int MathUtils_obj::signum(Float value){
            	HX_STACKFRAME(&_hx_pos_7db36b66451a9438_51_signum)
HXDLIN(  51)		if ((value > 0)) {
HXDLIN(  51)			return 1;
            		}
            		else {
HXDLIN(  51)			if ((value < 0)) {
HXDLIN(  51)				return -1;
            			}
            			else {
HXDLIN(  51)				return 0;
            			}
            		}
HXDLIN(  51)		return 0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(MathUtils_obj,signum,return )

int MathUtils_obj::random(int max){
            	HX_STACKFRAME(&_hx_pos_7db36b66451a9438_55_random)
HXDLIN(  55)		return ::Math_obj::round((( (Float)(max) ) * ::Math_obj::random()));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(MathUtils_obj,random,return )

int MathUtils_obj::minInt(int a,int b){
            	HX_STACKFRAME(&_hx_pos_7db36b66451a9438_59_minInt)
HXDLIN(  59)		if ((a < b)) {
HXDLIN(  59)			return a;
            		}
            		else {
HXDLIN(  59)			return b;
            		}
HXDLIN(  59)		return 0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(MathUtils_obj,minInt,return )

int MathUtils_obj::maxInt(int a,int b){
            	HX_STACKFRAME(&_hx_pos_7db36b66451a9438_63_maxInt)
HXDLIN(  63)		if ((a > b)) {
HXDLIN(  63)			return a;
            		}
            		else {
HXDLIN(  63)			return b;
            		}
HXDLIN(  63)		return 0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(MathUtils_obj,maxInt,return )


MathUtils_obj::MathUtils_obj()
{
}

bool MathUtils_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"clamp") ) { outValue = clamp_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"radDeg") ) { outValue = ( radDeg ); return true; }
		if (HX_FIELD_EQ(inName,"degRad") ) { outValue = ( degRad ); return true; }
		if (HX_FIELD_EQ(inName,"cosDeg") ) { outValue = cosDeg_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"sinDeg") ) { outValue = sinDeg_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"signum") ) { outValue = signum_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"random") ) { outValue = random_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"minInt") ) { outValue = minInt_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"maxInt") ) { outValue = maxInt_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"radToDeg") ) { outValue = radToDeg_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"degToRad") ) { outValue = degToRad_dyn(); return true; }
	}
	return false;
}

bool MathUtils_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"radDeg") ) { radDeg=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"degRad") ) { degRad=ioValue.Cast< Float >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *MathUtils_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo MathUtils_obj_sStaticStorageInfo[] = {
	{::hx::fsInt,(void *) &MathUtils_obj::MAX_INT,HX_("MAX_INT",54,26,6d,69)},
	{::hx::fsInt,(void *) &MathUtils_obj::MIN_INT,HX_("MIN_INT",42,3c,46,da)},
	{::hx::fsFloat,(void *) &MathUtils_obj::radDeg,HX_("radDeg",f1,ae,da,b0)},
	{::hx::fsFloat,(void *) &MathUtils_obj::degRad,HX_("degRad",af,33,7c,67)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void MathUtils_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(MathUtils_obj::MAX_INT,"MAX_INT");
	HX_MARK_MEMBER_NAME(MathUtils_obj::MIN_INT,"MIN_INT");
	HX_MARK_MEMBER_NAME(MathUtils_obj::radDeg,"radDeg");
	HX_MARK_MEMBER_NAME(MathUtils_obj::degRad,"degRad");
};

#ifdef HXCPP_VISIT_ALLOCS
static void MathUtils_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(MathUtils_obj::MAX_INT,"MAX_INT");
	HX_VISIT_MEMBER_NAME(MathUtils_obj::MIN_INT,"MIN_INT");
	HX_VISIT_MEMBER_NAME(MathUtils_obj::radDeg,"radDeg");
	HX_VISIT_MEMBER_NAME(MathUtils_obj::degRad,"degRad");
};

#endif

::hx::Class MathUtils_obj::__mClass;

static ::String MathUtils_obj_sStaticFields[] = {
	HX_("MAX_INT",54,26,6d,69),
	HX_("MIN_INT",42,3c,46,da),
	HX_("radDeg",f1,ae,da,b0),
	HX_("degRad",af,33,7c,67),
	HX_("radToDeg",f6,40,04,dd),
	HX_("degToRad",74,8f,b4,95),
	HX_("cosDeg",bf,97,06,cb),
	HX_("sinDeg",8e,d1,06,b9),
	HX_("clamp",fb,72,58,48),
	HX_("signum",d5,3f,86,b4),
	HX_("random",03,22,8f,b7),
	HX_("minInt",7d,7a,e6,52),
	HX_("maxInt",ab,f8,4d,be),
	::String(null())
};

void MathUtils_obj::__register()
{
	MathUtils_obj _hx_dummy;
	MathUtils_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("spinehaxe.MathUtils",84,5c,65,e9);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &MathUtils_obj::__GetStatic;
	__mClass->mSetStaticField = &MathUtils_obj::__SetStatic;
	__mClass->mMarkFunc = MathUtils_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(MathUtils_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< MathUtils_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = MathUtils_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = MathUtils_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = MathUtils_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void MathUtils_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_7db36b66451a9438_4_boot)
HXDLIN(   4)		MAX_INT = (int)2147483647;
            	}
{
            	HX_STACKFRAME(&_hx_pos_7db36b66451a9438_5_boot)
HXDLIN(   5)		MIN_INT = (int)-2147483648;
            	}
{
            	HX_STACKFRAME(&_hx_pos_7db36b66451a9438_7_boot)
HXDLIN(   7)		radDeg = (( (Float)(180) ) / ::Math_obj::PI);
            	}
{
            	HX_STACKFRAME(&_hx_pos_7db36b66451a9438_8_boot)
HXDLIN(   8)		degRad = (::Math_obj::PI / ( (Float)(180) ));
            	}
}

} // end namespace spinehaxe
